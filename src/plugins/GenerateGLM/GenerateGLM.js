/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Mon Apr 04 2016 12:03:32 GMT-0700 (PDT).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'common/util/ejs', // for ejs templates
    'common/util/xmljsonconverter', // used to save model as json
    'gridlabd/meta',
    'gridlabd/modelLoader',
    'plugin/GenerateGLM/GenerateGLM/Templates/Templates',
    'q'
], function (
    PluginConfig,
    PluginBase,
    ejs,
    Converter,
    MetaTypes,
    loader,
    TEMPLATES,
    Q) {
    'use strict';

    /**
     * Initializes a new instance of GenerateGLM.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin GenerateGLM.
     * @constructor
     */
    var GenerateGLM = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.metaTypes = MetaTypes;
    };

    // Prototypal inheritance from PluginBase.
    GenerateGLM.prototype = Object.create(PluginBase.prototype);
    GenerateGLM.prototype.constructor = GenerateGLM;

    /**
     * Gets the name of the GenerateGLM.
     * @returns {string} The name of the plugin.
     * @public
     */
    GenerateGLM.prototype.getName = function () {
        return 'GenerateGLM';
    };

    /**
     * Gets the semantic version (semver.org) of the GenerateGLM.
     * @returns {string} The version of the plugin.
     * @public
     */
    GenerateGLM.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    GenerateGLM.prototype.getConfigStructure = function() {
        return [
	    {
		'name': 'returnZip',
		'displayName': 'Zip and return generated GLM.',
		'description': 'If true, it enables the client to download a zip of the model.',
		'value': false,
		'valueType': 'boolean',
		'readOnly': false
	    }
        ];
    };

    GenerateGLM.prototype.notify = function(level, msg) {
	var self = this;
	var prefix = self.projectId + '::' + self.projectName + '::' + level + '::';
	if (level=='error')
	    self.logger.error(msg);
	else if (level=='debug')
	    self.logger.debug(msg);
	else if (level=='info')
	    self.logger.info(msg);
	else if (level=='warning')
	    self.logger.warn(msg);
	self.createMessage(self.activeNode, msg, level);
	self.sendNotification(prefix+msg);
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    GenerateGLM.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
        modelNode;

	self.result.success = false;
	self.runningOnServer = true;

        if (typeof WebGMEGlobal !== 'undefined') {
	    self.runningOnServer = false;
        }

	self.updateMETA(self.metaTypes);

	// What did the user select for our configuration?
	var currentConfig = self.getCurrentConfig();
	self.returnZip = currentConfig.returnZip;

        modelNode = self.activeNode;
	self.modelName = self.core.getAttribute(modelNode, 'name');
	self.model = {};
	self.fileData = '';
	self.fileName = self.modelName + '.glm';

	loader.logger = self.logger;
	return loader.loadPowerModel(self.core, modelNode)
	    .then(function(powerModel) {
		self.powerModel = powerModel;
		//self.logger.error(JSON.stringify(self.powerModel,null,2));
	    })
	    .then(function() {
		return self.renderFile();
	    })
	    .then(function() {
		return self.generateLocalArtifacts();
	    })
	    .then(function() {
		return self.generateBlobArtifacts();
	    })
	    .then(function() {
		self.result.setSuccess(true);
		self.createMessage(self.activeNode, 'Generated GLM.');
		callback(self.activeNode, self.result);
	    })
	    .catch(function(err) {
		self.result.setSuccess(false);
		self.createMessage(self.activeNode, err, 'error');
		callback(self.activeNode, self.result);
	    });
    };

    GenerateGLM.prototype.renderFile = function() {
	var self = this;
	var glmTemplate = TEMPLATES['GLM.ejs'];
	var commands = {
	    'profiler': 'set',
	    'threadcount': 'set',
	    'randomseed': 'set',
	    'relax_naming_rules': 'set',
	    'pauseat': 'set',
	    'iteration_limit': 'set',
	    'stylesheet': 'define',
	};
	var childTypes = [
	    'line_spacing',
	    'underground_line',
	    'underground_line_conductor',
	    //'underground_line_configuration',
	    'line_configuration',
	    'overhead_line',
	    'overhead_line_conductor',
	    //'overhead_line_configuration',
	    'triplex_line',
	    'triplex_line_conductor',
	    'triplex_line_configuration',
	    'transformer',
	    'transformer_configuration',
	    'capacitor',
	    'node',
	    'load',
	    'triplex_node',
	    'triplex_meter',
	    'regulator',
	    'regulator_configuration',
	    'auction',
	    'house',
	    'waterheater',
	    'controller',
	    'multi_recorder',
	];
	var pointerDict = {
	    'underground_line': {
		'src': 'from',
		'dst': 'to',
		'configuration': 'configuration',
	    },
	    'overhead_line': {
		'src': 'from',
		'dst': 'to',
		'configuration': 'configuration',
	    },
	    'triplex_line': {
		'src': 'from',
		'dst': 'to',
		'configuration': 'configuration',
	    },
	    'transformer': {
		'src': 'from',
		'dst': 'to',
		'configuration': 'configuration',
	    },
	    'regulator': {
		'src': 'from',
		'dst': 'to',
		'configuration': 'configuration',
		'sense_node': 'sense_node',
	    },
	    'line_configuration': {
		'conductor_A': 'conductor_A',
		'conductor_B': 'conductor_B',
		'conductor_C': 'conductor_C',
		'conductor_N': 'conductor_N',
		'spacing': 'spacing',
	    },
	    'triplex_line_configuration': {
		'conductor_1': 'conductor_1',
		'conductor_2': 'conductor_2',
		'conductor_N': 'conductor_N',
		'spacing': 'spacing',
	    },
	    'switch': {
		'src': 'from',
		'dst': 'to',
	    },
	    'node': {
		'parent': 'parent',
	    },
	    'capacitor': {
		'parent': 'parent',
	    },
	    'house': {
		'parent': 'parent',
	    },
	    'waterheater': {
		'parent': 'parent',
	    },
	    'controller': {
		'market': 'market',
		'parent': 'parent',
	    },
	};
	var modules = [
	    ['auction','market'],
	    ['climate','climate'],
	    ['multi_recorder','tape'],
	];
	try {
	    self.fileData = ejs.render(
		glmTemplate,
		{
		    model: self.powerModel, 
		    commands: commands, 
		    childTypes: childTypes,
		    pointerDict: pointerDict,
		    modules: modules
		}
	    );
	}
	catch (err) {
	    throw new String('Rendering File failed: ' + err);
	}
    };

    GenerateGLM.prototype.generateLocalArtifacts = function() {
	var self = this;
	if (!self.runningOnServer) {
	    self.notify('info', 'Running in client, skipping file-system GLM generation');
	    return;
	}

	var path = require('path');
	self.root_dir = path.join(process.cwd(), 
				  'generated', 
				  self.project.projectId, 
				  self.branchName,
				  'models');
    };

    GenerateGLM.prototype.generateBlobArtifacts = function() {
	var self = this;
	if (!self.returnZip) {
	    self.notify('info', 'User did not request the model to be returned.');
	    return;
	}
	return self.blobClient.putFile(self.fileName, self.fileData)
	    .then(function (hash) {
		self.result.addArtifact(hash);
	    });
    };

    return GenerateGLM;
});
